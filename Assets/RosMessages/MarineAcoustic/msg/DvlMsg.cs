//Do not edit! This file was generated by Unity-ROS MessageGeneration.
using System;
using System.Linq;
using System.Collections.Generic;
using System.Text;
using Unity.Robotics.ROSTCPConnector.MessageGeneration;

namespace RosMessageTypes.MarineAcoustic
{
    [Serializable]
    public class DvlMsg : Message
    {
        public const string k_RosMessageName = "marine_acoustic_msgs/Dvl";
        public override string RosMessageName => k_RosMessageName;

        //  Message for single ground-track ping from a DVL.
        // 
        //  This message is modeled after WHOI's Dvl.msg from the ds_sensor_msgs
        //  repository, which was released under a BSD license.
        //  Modifications were made by UW-APL.
        //  ENUM: Velocity mode
        public const byte DVL_MODE_BOTTOM = 1;
        public const byte DVL_MODE_WATER = 2;
        //  ENUM: DVL Type; used in sound velocity corrections
        //  Standard (Janus) array with one piston transducer for each beam.
        //  If you have 4-5 individual disks on your DVL, use this one.
        //  Examples include Sonardyne Syrinx, Nortek DVLs, and RDI Workhorse
        public const byte DVL_TYPE_PISTON = 0;
        //  Phased-array DVL.  If you have one giant disk with complicated stuff
        //  on it, probably this one.
        //  Examples include newer RDI DVLs such as pathfinder, pioneer, and tasman.
        public const byte DVL_TYPE_PHASED_ARRAY = 1;
        //  The standard ROS header.
        //  Timestamp is neither transmit nor receive time -- it is the time that
        //  the velocity should be considered valid at.
        //  Frame convention:
        //  * z-axis in direction DVL is pointing
        //  * x-axis aligned with vehicle forward
        public Std.HeaderMsg header;
        //  Velocity mode (see above)
        public byte velocity_mode;
        //  Type of DVL array employed (see above).  Necessary when
        //  deciding how to apply sound velocity corrections
        public byte dvl_type;
        //  Velocities [m/s]
        public Geometry.Vector3Msg velocity;
        //  row-major, xyz axes.  Set to "-1" if not known.
        public double[] velocity_covar;
        //  Average altitude of all good beam returns.
        //  For 30-deg sensor, altitude = (sqrt(3) / 2) * sum(range) / num_good_beams
        public double altitude;
        //  Calculated from xy velocities: course_gnd = atan2(velocity.y, velocity.x)
        public double course_gnd;
        //  Calculated from xy velocities: speed_gnd = sqrt(velocity.x^2 + velocity.y^2)
        public double speed_gnd;
        public byte num_good_beams;
        //  Speed of sound (m/s) used by the DVL
        public float sound_speed;
        //  Beam data
        //  Some DVLs/DVL configurations only report the derived velocities.
        public bool beam_ranges_valid;
        public bool beam_velocities_valid;
        //  Geometry of each of the 4 beams
        public Geometry.Vector3Msg[] beam_unit_vec;
        //  beam_unit_vec[i] * range[i] is the point where the beam hits the seafloor.
        //  For a 30-deg sensor, multiply by sqrt(3)/2 to get altitude.
        public double[] range;
        public float[] range_covar;
        //  Beam quality flag.
        //  The meaning of this flag is DVL-specific (at least for now).
        public float[] beam_quality;
        //  Raw velocities for each beam [m/s].
        //  Will be beam 1,2,3,4 velocity in beam coordinates
        public float[] beam_velocity;
        //  Covariance, as always, should be -1 if unknown
        public float[] beam_velocity_covar;

        public DvlMsg()
        {
            this.header = new Std.HeaderMsg();
            this.velocity_mode = 0;
            this.dvl_type = 0;
            this.velocity = new Geometry.Vector3Msg();
            this.velocity_covar = new double[9];
            this.altitude = 0.0;
            this.course_gnd = 0.0;
            this.speed_gnd = 0.0;
            this.num_good_beams = 0;
            this.sound_speed = 0.0f;
            this.beam_ranges_valid = false;
            this.beam_velocities_valid = false;
            this.beam_unit_vec = new Geometry.Vector3Msg[4];
            this.range = new double[4];
            this.range_covar = new float[4];
            this.beam_quality = new float[4];
            this.beam_velocity = new float[4];
            this.beam_velocity_covar = new float[4];
        }

        public DvlMsg(Std.HeaderMsg header, byte velocity_mode, byte dvl_type, Geometry.Vector3Msg velocity, double[] velocity_covar, double altitude, double course_gnd, double speed_gnd, byte num_good_beams, float sound_speed, bool beam_ranges_valid, bool beam_velocities_valid, Geometry.Vector3Msg[] beam_unit_vec, double[] range, float[] range_covar, float[] beam_quality, float[] beam_velocity, float[] beam_velocity_covar)
        {
            this.header = header;
            this.velocity_mode = velocity_mode;
            this.dvl_type = dvl_type;
            this.velocity = velocity;
            this.velocity_covar = velocity_covar;
            this.altitude = altitude;
            this.course_gnd = course_gnd;
            this.speed_gnd = speed_gnd;
            this.num_good_beams = num_good_beams;
            this.sound_speed = sound_speed;
            this.beam_ranges_valid = beam_ranges_valid;
            this.beam_velocities_valid = beam_velocities_valid;
            this.beam_unit_vec = beam_unit_vec;
            this.range = range;
            this.range_covar = range_covar;
            this.beam_quality = beam_quality;
            this.beam_velocity = beam_velocity;
            this.beam_velocity_covar = beam_velocity_covar;
        }

        public static DvlMsg Deserialize(MessageDeserializer deserializer) => new DvlMsg(deserializer);

        private DvlMsg(MessageDeserializer deserializer)
        {
            this.header = Std.HeaderMsg.Deserialize(deserializer);
            deserializer.Read(out this.velocity_mode);
            deserializer.Read(out this.dvl_type);
            this.velocity = Geometry.Vector3Msg.Deserialize(deserializer);
            deserializer.Read(out this.velocity_covar, sizeof(double), 9);
            deserializer.Read(out this.altitude);
            deserializer.Read(out this.course_gnd);
            deserializer.Read(out this.speed_gnd);
            deserializer.Read(out this.num_good_beams);
            deserializer.Read(out this.sound_speed);
            deserializer.Read(out this.beam_ranges_valid);
            deserializer.Read(out this.beam_velocities_valid);
            deserializer.Read(out this.beam_unit_vec, Geometry.Vector3Msg.Deserialize, 4);
            deserializer.Read(out this.range, sizeof(double), 4);
            deserializer.Read(out this.range_covar, sizeof(float), 4);
            deserializer.Read(out this.beam_quality, sizeof(float), 4);
            deserializer.Read(out this.beam_velocity, sizeof(float), 4);
            deserializer.Read(out this.beam_velocity_covar, sizeof(float), 4);
        }

        public override void SerializeTo(MessageSerializer serializer)
        {
            serializer.Write(this.header);
            serializer.Write(this.velocity_mode);
            serializer.Write(this.dvl_type);
            serializer.Write(this.velocity);
            serializer.Write(this.velocity_covar);
            serializer.Write(this.altitude);
            serializer.Write(this.course_gnd);
            serializer.Write(this.speed_gnd);
            serializer.Write(this.num_good_beams);
            serializer.Write(this.sound_speed);
            serializer.Write(this.beam_ranges_valid);
            serializer.Write(this.beam_velocities_valid);
            serializer.Write(this.beam_unit_vec);
            serializer.Write(this.range);
            serializer.Write(this.range_covar);
            serializer.Write(this.beam_quality);
            serializer.Write(this.beam_velocity);
            serializer.Write(this.beam_velocity_covar);
        }

        public override string ToString()
        {
            return "DvlMsg: " +
            "\nheader: " + header.ToString() +
            "\nvelocity_mode: " + velocity_mode.ToString() +
            "\ndvl_type: " + dvl_type.ToString() +
            "\nvelocity: " + velocity.ToString() +
            "\nvelocity_covar: " + System.String.Join(", ", velocity_covar.ToList()) +
            "\naltitude: " + altitude.ToString() +
            "\ncourse_gnd: " + course_gnd.ToString() +
            "\nspeed_gnd: " + speed_gnd.ToString() +
            "\nnum_good_beams: " + num_good_beams.ToString() +
            "\nsound_speed: " + sound_speed.ToString() +
            "\nbeam_ranges_valid: " + beam_ranges_valid.ToString() +
            "\nbeam_velocities_valid: " + beam_velocities_valid.ToString() +
            "\nbeam_unit_vec: " + System.String.Join(", ", beam_unit_vec.ToList()) +
            "\nrange: " + System.String.Join(", ", range.ToList()) +
            "\nrange_covar: " + System.String.Join(", ", range_covar.ToList()) +
            "\nbeam_quality: " + System.String.Join(", ", beam_quality.ToList()) +
            "\nbeam_velocity: " + System.String.Join(", ", beam_velocity.ToList()) +
            "\nbeam_velocity_covar: " + System.String.Join(", ", beam_velocity_covar.ToList());
        }

#if UNITY_EDITOR
        [UnityEditor.InitializeOnLoadMethod]
#else
        [UnityEngine.RuntimeInitializeOnLoadMethod]
#endif
        public static void Register()
        {
            MessageRegistry.Register(k_RosMessageName, Deserialize);
        }
    }
}
