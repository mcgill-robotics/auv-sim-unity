using UnityEngine;

/// <summary>
/// Applies hydrodynamic drag to the AUV using a pre-computed spherical lookup table
/// of projected areas AND center of pressure offsets.
/// 
/// The center of pressure offset allows realistic drag torques when moving at angles.
/// Force is applied at the pressure center, creating natural weathervane behavior.
/// 
/// The lookup table is generated by the DragLookupBaker Editor script.
/// </summary>
[RequireComponent(typeof(Rigidbody))]
public class HydrodynamicDrag : MonoBehaviour
{
    public enum DragAreaMode
    {
        ConstantArea,
        LookupTable
    }

    [Header("Drag Model")]
    [Tooltip("Method for computing projected area")]
    public DragAreaMode dragAreaMode = DragAreaMode.LookupTable;

    [Header("Fluid Properties")]
    [Tooltip("Water density in kg/m³ (freshwater ≈ 1000, seawater ≈ 1025)")]
    public float waterDensity = 1000f;
    
    [Tooltip("Drag coefficient (0.4-0.5 for streamlined, 1.0-1.2 for blunt bodies)")]
    [Range(0.1f, 2f)]
    public float dragCoefficient = 0.8f;

    [Header("Constant Area Mode")]
    [Tooltip("Fixed cross-sectional area in m² (used when mode = ConstantArea)")]
    public float constantArea = 0.25f;

    [Header("Lookup Table Mode")]
    [Tooltip("JSON file containing the baked projected area lookup table")]
    public TextAsset lookupTableJson;
    
    [Tooltip("Apply force at center of pressure (creates torque). Disable for CoM-only drag.")]
    public bool useCenterOfPressure = true;


    [Header("Debug")]
    [Tooltip("Log drag force each frame")]
    public bool debugLogging = false;
    [Tooltip("Visualize drag force and pressure center")]
    public bool visualize = false;

    private Rigidbody rb;
    
    // Lookup table data
    private float[,] projectedAreaLookup;
    private float[,] offsetXLookup;  // Camera-local X offset (meters)
    private float[,] offsetYLookup;  // Camera-local Y offset (meters)
    private int nLon, nLat;
    private bool lookupLoaded = false;
    private bool hasOffsetData = false;

    private void Awake()
    {
        rb = GetComponent<Rigidbody>();
        rb.linearDamping = 0f;
        // rb.angularDamping = 0f;
    }

    private void Start()
    {
        if (dragAreaMode == DragAreaMode.LookupTable)
        {
            LoadLookupTable();
        }
    }

    private void FixedUpdate()
    {
        // Only apply drag when underwater
        if (transform.position.y > 0) return;
        
        ApplyHydrodynamicDrag();
    }

    private void ApplyHydrodynamicDrag()
    {
        Vector3 velocity = rb.linearVelocity;
        float speedSqr = velocity.sqrMagnitude;

        if (speedSqr < 0.0001f) return;

        float speed = Mathf.Sqrt(speedSqr);
        Vector3 velocityDir = velocity / speed;

        // Get projected area and pressure center offset
        float area = GetProjectedArea(velocityDir, out Vector3 pressureOffset);

        // Drag force: F = 0.5 * ρ * A * Cd * v²
        float forceMagnitude = 0.5f * waterDensity * area * dragCoefficient * speedSqr;
        Vector3 dragForce = -velocityDir * forceMagnitude;

        // Apply force at pressure center (creates torque) or at CoM
        if (useCenterOfPressure && hasOffsetData && pressureOffset.sqrMagnitude > 0.0001f)
        {
            Vector3 worldPressureCenter = rb.worldCenterOfMass + transform.TransformDirection(pressureOffset);
            rb.AddForceAtPosition(dragForce, worldPressureCenter, ForceMode.Force);

            if (visualize)
            {
                Debug.DrawLine(rb.worldCenterOfMass, worldPressureCenter, Color.yellow);
                Debug.DrawRay(worldPressureCenter, dragForce.normalized * 0.5f, Color.red);
            }
        }
        else
        {
            rb.AddForce(dragForce, ForceMode.Force);
            
            if (visualize)
            {
                Debug.DrawRay(rb.worldCenterOfMass, dragForce.normalized * 0.5f, Color.red);
            }
        }

        if (debugLogging)
        {
            Debug.Log($"[Drag] Speed: {speed:F2} m/s, Area: {area:F4} m², Force: {forceMagnitude:F1} N, Offset: {pressureOffset}");
        }
    }

    private float GetProjectedArea(Vector3 velocityDir, out Vector3 pressureOffset)
    {
        pressureOffset = Vector3.zero;

        switch (dragAreaMode)
        {
            case DragAreaMode.ConstantArea:
                return constantArea;

            case DragAreaMode.LookupTable:
                return lookupLoaded ? SampleLookupTable(velocityDir, out pressureOffset) : constantArea;

            default:
                return constantArea;
        }
    }


    private void LoadLookupTable()
    {
        if (lookupTableJson == null)
        {
            Debug.LogWarning("[HydrodynamicDrag] No lookup table assigned. Falling back to constant area.");
            return;
        }

        try
        {
            DragLookupData data = JsonUtility.FromJson<DragLookupData>(lookupTableJson.text);
            nLon = data.longitudeSamples;
            nLat = data.latitudeSamples;
            projectedAreaLookup = new float[nLat, nLon];
            
            // Load area data
            for (int i = 0; i < nLat; i++)
            {
                for (int j = 0; j < nLon; j++)
                {
                    projectedAreaLookup[i, j] = data.flatData[i * nLon + j];
                }
            }

            // Load offset data if available
            if (data.offsetXData != null && data.offsetYData != null && 
                data.offsetXData.Length == nLat * nLon && data.offsetYData.Length == nLat * nLon)
            {
                offsetXLookup = new float[nLat, nLon];
                offsetYLookup = new float[nLat, nLon];
                
                for (int i = 0; i < nLat; i++)
                {
                    for (int j = 0; j < nLon; j++)
                    {
                        offsetXLookup[i, j] = data.offsetXData[i * nLon + j];
                        offsetYLookup[i, j] = data.offsetYData[i * nLon + j];
                    }
                }
                hasOffsetData = true;
                Debug.Log($"[HydrodynamicDrag] Loaded lookup table with pressure center offsets: {nLon}×{nLat}");
            }
            else
            {
                hasOffsetData = false;
                Debug.Log($"[HydrodynamicDrag] Loaded lookup table (no offset data): {nLon}×{nLat}");
            }

            lookupLoaded = true;
        }
        catch (System.Exception e)
        {
            Debug.LogError($"[HydrodynamicDrag] Failed to load lookup table: {e.Message}");
            lookupLoaded = false;
        }
    }

    private float SampleLookupTable(Vector3 velocityDir, out Vector3 pressureOffset)
    {
        // Convert velocity direction to the AUV's local frame
        Vector3 localDir = transform.InverseTransformDirection(velocityDir);

        // Convert Cartesian to spherical coordinates
        float lat = Mathf.Asin(Mathf.Clamp(localDir.y, -1f, 1f));
        float lon = Mathf.Atan2(localDir.x, localDir.z);
        if (lon < 0) lon += 2f * Mathf.PI;

        // Map to continuous indices
        // Latitude: +π/2 (top) = v=0, -π/2 (bottom) = v=nLat-1 (matches Baker)
        float u = lon / (2f * Mathf.PI) * nLon; // 0 to nLon
        float v = (0.5f - lat / Mathf.PI) * (nLat - 1); // Inverted to match Baker

        // Get integer and fractional parts for Bilinear Interpolation
        int x0 = Mathf.FloorToInt(u) % nLon;
        int x1 = (x0 + 1) % nLon; // Wrap around longitude
        float u_frac = u - Mathf.Floor(u);

        int y0 = Mathf.Clamp(Mathf.FloorToInt(v), 0, nLat - 1);
        int y1 = Mathf.Clamp(y0 + 1, 0, nLat - 1); // Clamp latitude (no wrap)
        float v_frac = v - y0;

        // Helper to get data safely
        float GetArea(int x, int y) => projectedAreaLookup[y, x];

        // Bilinear Interpolation for Area
        float areaBot = Mathf.Lerp(GetArea(x0, y0), GetArea(x1, y0), u_frac);
        float areaTop = Mathf.Lerp(GetArea(x0, y1), GetArea(x1, y1), u_frac);
        float finalArea = Mathf.Lerp(areaBot, areaTop, v_frac);

        pressureOffset = Vector3.zero;

        if (hasOffsetData)
        {
            float GetOffX(int x, int y) => offsetXLookup[y, x];
            float GetOffY(int x, int y) => offsetYLookup[y, x];

            // Interpolate X Offset
            float oxBot = Mathf.Lerp(GetOffX(x0, y0), GetOffX(x1, y0), u_frac);
            float oxTop = Mathf.Lerp(GetOffX(x0, y1), GetOffX(x1, y1), u_frac);
            float finalOffX = Mathf.Lerp(oxBot, oxTop, v_frac);

            // Interpolate Y Offset
            float oyBot = Mathf.Lerp(GetOffY(x0, y0), GetOffY(x1, y0), u_frac);
            float oyTop = Mathf.Lerp(GetOffY(x0, y1), GetOffY(x1, y1), u_frac);
            float finalOffY = Mathf.Lerp(oyBot, oyTop, v_frac);

            // Basis Construction
            // Standardize basis to match Baker's Camera orientation
            Vector3 right, up;
            if (Mathf.Abs(localDir.y) > 0.99f) // Increased threshold for stability at poles
            {
                right = Vector3.Cross(Vector3.forward, localDir).normalized;
            }
            else
            {
                right = Vector3.Cross(Vector3.up, localDir).normalized;
            }
            up = Vector3.Cross(localDir, right).normalized;

            // Apply offsets
            // CRITICAL: Negate X offset because Baker camera looks AT object (rotated 180 deg)
            // Screen Right in baking = World Left relative to velocity vector
            pressureOffset = right * (-finalOffX) + up * finalOffY;
        }

        return finalArea;
    }

}

/// <summary>
/// Serializable data structure for the drag lookup table.
/// Uses flat arrays with row-major indexing: data[lat * nLon + lon]
/// </summary>
[System.Serializable]
public class DragLookupData
{
    public int longitudeSamples;
    public int latitudeSamples;
    public float[] flatData;      // Projected area (m²)
    public float[] offsetXData;   // Pressure center X offset (m)
    public float[] offsetYData;   // Pressure center Y offset (m)
}
